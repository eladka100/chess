IDEAL
MODEL small
STACK 100h
DATASEG




DrawButton db 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h
		   db 00h, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 00h
		   db 00h, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 00h
		   db 00h, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 00h
		   db 00h, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 00h
		   db 00h, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 00h, 00h, 00h, 0Fh, 0Fh, 00h, 00h, 00h, 0Fh, 0Fh, 0Fh, 00h, 00h, 0Fh, 0Fh, 00h, 0Fh, 0Fh, 0Fh, 00h, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 00h
		   db 00h, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 00h, 0Fh, 0Fh, 00h, 0Fh, 00h, 0Fh, 0Fh, 00h, 0Fh, 00h, 0Fh, 0Fh, 00h, 0Fh, 00h, 0Fh, 0Fh, 0Fh, 00h, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 00h
		   db 00h, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 00h, 0Fh, 0Fh, 00h, 0Fh, 00h, 00h, 00h, 0Fh, 0Fh, 00h, 00h, 00h, 00h, 0Fh, 00h, 0Fh, 00h, 0Fh, 00h, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 00h
		   db 00h, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 00h, 0Fh, 0Fh, 00h, 0Fh, 00h, 0Fh, 00h, 0Fh, 0Fh, 00h, 0Fh, 0Fh, 00h, 0Fh, 00h, 00h, 0Fh, 00h, 00h, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 00h
		   db 00h, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 00h, 00h, 00h, 0Fh, 0Fh, 00h, 0Fh, 0Fh, 00h, 0Fh, 00h, 0Fh, 0Fh, 00h, 0Fh, 00h, 0Fh, 0Fh, 0Fh, 00h, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 00h
		   db 00h, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 00h
		   db 00h, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 00h
		   db 00h, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 00h
		   db 00h, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 00h
		   db 00h, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 00h
		   db 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h

ResignButton db 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h
		   db 00h, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 00h
		   db 00h, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 00h
		   db 00h, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 00h
		   db 00h, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 00h
		   db 00h, 0Fh, 00h, 00h, 00h, 0Fh, 0Fh, 00h, 00h, 00h, 00h, 0Fh, 0Fh, 00h, 00h, 00h, 0Fh, 00h, 00h, 00h, 0Fh, 0Fh, 00h, 00h, 0Fh, 0Fh, 00h, 0Fh, 0Fh, 00h, 0Fh, 00h
		   db 00h, 0Fh, 00h, 0Fh, 0Fh, 00h, 0Fh, 00h, 0Fh, 0Fh, 0Fh, 0Fh, 00h, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 00h, 0Fh, 0Fh, 00h, 0Fh, 0Fh, 0Fh, 0Fh, 00h, 00h, 0Fh, 00h, 0Fh, 00h
		   db 00h, 0Fh, 00h, 00h, 00h, 0Fh, 0Fh, 00h, 00h, 00h, 0Fh, 0Fh, 0Fh, 00h, 00h, 0Fh, 0Fh, 0Fh, 00h, 0Fh, 0Fh, 00h, 0Fh, 00h, 00h, 0Fh, 00h, 0Fh, 00h, 00h, 0Fh, 00h
		   db 00h, 0Fh, 00h, 0Fh, 00h, 0Fh, 0Fh, 00h, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 00h, 0Fh, 0Fh, 00h, 0Fh, 0Fh, 00h, 0Fh, 0Fh, 00h, 0Fh, 00h, 0Fh, 0Fh, 00h, 0Fh, 00h
		   db 00h, 0Fh, 00h, 0Fh, 0Fh, 00h, 0Fh, 00h, 00h, 00h, 00h, 0Fh, 00h, 00h, 00h, 0Fh, 0Fh, 00h, 00h, 00h, 0Fh, 0Fh, 00h, 00h, 0Fh, 0Fh, 00h, 0Fh, 0Fh, 00h, 0Fh, 00h
		   db 00h, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 00h
		   db 00h, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 00h
		   db 00h, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 00h
		   db 00h, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 00h
		   db 00h, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 00h
		   db 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h
		   
isDraw db 00h
isResign db 00h
		   
; piece sprite format: t - transparent, b - border, a - inside

Spawn db "tttttttttttttttt"
	  db "ttttttbbbbtttttt"
	  db "tttttbaaaabttttt"
	  db "tttttbaaaabttttt"
	  db "ttttttbaabtttttt"
	  db "ttttttbaabtttttt"
	  db "ttttttbaabtttttt"
	  db "ttttttbaabtttttt"
	  db "ttttttbaabtttttt"
	  db "ttttttbaabtttttt"
	  db "ttttttbaabtttttt"
	  db "tttbbbbbbbbbbttt"
	  db "ttbaaaaaaaaaabtt"
	  db "ttbbbbbbbbbbbbtt"
	  db "tttttttttttttttt"

Srook db "tttttttttttttttt"
	  db "ttttbbtbbtbbtttt"
	  db "tttbaabaabaabttt"
	  db "tttbaabaabaabttt"
	  db "tttbaaaaaaaabttt"
	  db "ttttbbaaaabbtttt"
	  db "tttttbaaaabttttt"
	  db "tttttbaaaabttttt"
	  db "tttttbaaaabttttt"
	  db "tttttbaaaabttttt"
	  db "tttttbaaaabttttt"
	  db "tttbbbbbbbbbbttt"
	  db "ttbaaaaaaaaaabtt"
	  db "ttbbbbbbbbbbbbtt"
	  db "tttttttttttttttt"

Sknight db "tttttttttttttttt"
		db "tttttttbbbtttttt"
		db "ttttttbaaabttttt"
		db "tttttbaaaaabtttt"
		db "tttttbaaaaaabttt"
		db "tttttbaaaaaabttt"
		db "tttttbaabbbbbttt"
		db "tttttbaabttttttt"
		db "tttttbaaabtttttt"
		db "tttttbaaabtttttt"
		db "tttttbaaaabttttt"
		db "tttttbaaaabttttt"
		db "tttbbbbbbbbbbttt"
		db "ttbaaaaaaaaaabtt"
		db "ttbbbbbbbbbbbbtt"
		db "tttttttttttttttt"

Sbishop db "tttttttttttttttt"
		db "tttttttbbttttttt"
		db "ttttttbaabtttttt"
		db "tttttbaaaabttttt"
		db "ttttbaaaababtttt"
		db "ttttbaaabaabtttt"
		db "ttttbbaaaabbtttt"
		db "tttttbaaaabttttt"
		db "tttttbaaaabttttt"
		db "tttttbaaaabttttt"
		db "tttttbaaaabttttt"
		db "tttbbbbbbbbbbttt"
		db "ttbaaaaaaaaaabtt"
		db "ttbbbbbbbbbbbbtt"
		db "tttttttttttttttt"
		
Squeen db "tttttttttttttttt"
	   db "tttttttttttttttt"
	   db "tttttttbbttttttt"
	   db "ttbttttbbttttbtt"
	   db "tbabttbaabttbabt"
	   db "tbabttbaabttbabt"
	   db "tbaabtbaabtbaabt"
	   db "ttbabtbaabtbabtt"
	   db "ttbaabbaabbaabtt"
	   db "tttbaabaabaabttt"
	   db "tttbaabaabaabttt"
	   db "ttttbabaababtttt"
	   db "tttbbbbbbbbbbttt"
	   db "ttbaaaaaaaaaabtt"
	   db "ttbbbbbbbbbbbbtt"
	   db "tttttttttttttttt"
	   
Sking db "tttttttttttttttt"
	  db "tttttttbbttttttt"
	  db "ttttttbbbbtttttt"
	  db "tttttttbbttttttt"
	  db "ttttbbtbbtbbtttt"
	  db "tttbaabbbbaabttt"
	  db "tttbaaaaaaaabttt"
	  db "tttbaaaaaaaabttt"
	  db "tttbaaaaaaaabttt"
	  db "ttttbaaaaaabtttt"
	  db "ttttbaaaaaabtttt"
	  db "tttttbaaaabttttt"
	  db "tttbbbbbbbbbbttt"
	  db "ttbaaaaaaaaaabtt"
	  db "ttbbbbbbbbbbbbtt"
	  db "tttttttttttttttt"

	   
		
sprites dw 8 dup(offset promotionSprites), 2 dup(offset Srook), 2 dup(offset Sknight), 2 dup(offset Sbishop), offset Squeen, offset Sking


promotionSprites dw offset Spawn, offset Srook, offset Sknight, offset Sbishop, offset Squeen
;piece pos format: 1  2 (3 4 5) (6 7 8)
;            	     /     |       | 
;                 eaten   file    row
;             



Wpawns db 000001b, 001001b, 010001b, 011001b, 100001b, 101001b, 110001b, 111001b
Wrooks db 000000b, 111000b
Wknights db 001000b, 110000b
Wbishops db 010000b, 101000b
Wqueen db 011000b
Wking db 100000b

Bpawns db 000110b, 001110b, 010110b, 011110b, 100110b, 101110b, 110110b, 111110b
Brooks db 000111b, 111111b
Bknights db 001111b, 110111b
Bbishops db 010111b, 101111b
Bqueen db 011111b
Bking db 100111b

;promotions: 0 - pawn, 1 - rook, 2 - knight, 3 - bishop, 4 - queen


Wpromotions db 8 dup(00h)
Bpromotions db 8 dup (00h)

WmovedTwice db 8 dup (00h)
BmovedTwice db 8 dup (00h)

WsmallCastle db 00h
BsmallCastle db 00h
WbigCastle db 00h
BbigCastle db 00h


Xp dw 0000h
Yp dw 0000h
color db 00h

Xmouse dw 0000h
Ymouse dw 0000h

;piece numbers: 0-7 - pawn, 8-9 - rook, A-B - knight, C-D - bishop, E - queen, F - king
;piece format: 1 2 3 4 (5 6 7 8)
;            	    /      |       
;               color  piece num
;  
piece db 00h
targetTile db 00h
tile db 00h


promoMenu db 0Bh, 24, "rook knight bishop queen"
promoMenu2 db 0Bh, 24," 1     2      3      4   "
WwinStr db 0Fh, 11, "white wins!"
BwinStr db 0Fh, 11, "black wins!"
drawStr db 16h, 4, "draw"
exitStr db 0Fh, 21, "press any key to exit"


Xstr db 00h
Ystr db 00h
String dw 0000h

clock equ es:6Ch
ticker dw 0000h

Melody dw 0000h
natrualNotesTable dw 2A5Fh, 25E4h, 2394h, 1FB4h, 1C3Fh, 1AA2h, 17C7h
sharpNotesTable dw 27D6h, 2394h, 2188h, 1DE0h, 1AA2h, 1931h, 1668h
flatNotesTable dw 2CD0h, 27D6h, 25E4h, 2188h, 1DE0h, 1AA2h, 1931h

startMelody db "e$12 b$12 e$12 b$22 a21 f11 g14 ", 0
eatMelody db "a13 g03 g$04 f06 ", 0
winningMelody db "!3 b11 b11 b11 b12 c13 b11 a13 g01 b13 d11 d11 d11 d11 b12 d11 d11 d11 d11 d11 d11 d11 e13 d11 d11 d11 d11 d11 e13 d11 a13 g01 g03 d11 d11 d11 d11 d11 e13 b11 a13 g01 g01 ", 0
drawMelody db "b$12 e$14 e$13 c11 d14 g02 g02 c14 b$13 a$11 b$14 e$02 e$02 f04 f03 g01 a$14 a$13 b$11 c14 d12 e$12 f16 ", 0
enPassantMelody db "e$13 f13 b$12 f13 g13 b$21 g11 e$13 f13 b$14 ", 0
promotionMelody db "c11 e11 g11 c21 e11 g11 c21 e21 g11 c21 e21 g21 c21 e21 g21 e21 c34 ", 0
CheckMelody db "g#31 a$01 d04 ", 0


CODESEG

proc putPixel ; put a pixel of color [color] at ([Xp], [Yp])
	push ax
	push bx
	push cx
	push dx
	
	mov bh, 0h
	mov cx, [Xp]
	mov dx, [Yp]
	mov al, [color]
	mov ah, 0ch
	int 10h
	
	pop dx
	pop cx
	pop bx
	pop ax
	ret
endp putPixel

proc readPixel ; put a pixel of color [color] at ([Xp], [Yp])
	push ax
	push bx
	push cx
	push dx
	
	mov cx, [Xp]
	mov dx, [Yp]
	mov bh, 0h
	mov ah, 0dh
	int 10h
	mov [color], al
	
	pop dx
	pop cx
	pop bx
	pop ax
	ret
endp readPixel



proc displayBoard ; displays the chess board (without the pieces)
	push ax
	push bx
	push cx
	push dx
	
	mov ax, 96
	mov bx, 36	
	displayBoardTileLoop: ; loops through each tile
			mov [Xp], ax
			mov [Yp], bx
			mov cx, ax
			add cx, bx
			sub cx, 132
			and cx, 10000b ;checks if its a black or white tile	
			mov cx, 0
			mov dx, 0
			jz whiteTile
				mov [color], 00h ; it's black
				jmp displayBoardPaintLoop
			whiteTile:
				mov [color], 0Fh ; it's white
			
			displayBoardPaintLoop: ;loops through each pixel
					call putPixel
				inc cx
				inc [Xp]
				cmp cx, 16
				jb displayBoardPaintLoop
			mov cx, 0
			mov [Xp], ax
			inc dx
			inc [Yp]
			cmp dx, 16
			jb displayBoardPaintLoop
		add ax, 16
		cmp ax, 224
		jb displayBoardTileLoop
	mov ax, 96
	add bx, 16
	cmp bx, 164
	jb displayBoardTileLoop
	
	pop dx
	pop cx
	pop bx
	pop ax
	ret
endp displayBoard

proc background ; paint the background pattern
	push ax
	push bx
	push cx
	push dx
	
	mov [Xp], 0
	mov [Yp], 0
	backgroundLoop:
			mov ax, [Yp]
			shr ax, 2
			add ax, [Xp]
			and ax, 1b
			jz green
				mov [color], 06h
				jmp backgroundCon
			green:
				mov [color], 02h
			backgroundCon:
			call putPixel
			inc [Yp]
			call putPixel
			inc [Yp]
			call putPixel
			inc [Yp]
			call putPixel
			sub [Yp], 3
		inc [Xp]
		cmp [Xp], 320
		jb backgroundLoop
	mov [Xp], 0
	add [Yp], 4
	cmp [Yp], 200
	jb backgroundLoop
	
	pop dx
	pop cx
	pop bx
	pop ax
	ret
endp background

proc paintPiece
	push ax
	push bx
	push cx
	push dx
	push si
	
	mov ah, 0
	mov al, [piece]
	and al, 0Fh ; only look at the piece itself and not the color
	shl al, 1
	add ax, offset sprites
	mov si, ax
	mov si, [si] ; go to the start of the correct sprite
	
	mov bh, 0
	mov bl, [piece]
	add bx, offset Wpawns
	mov al, [bx]
	
	test al, 40h
	jnz paintPieceHelp; the piece is eaten and so it won't be painted
	
	mov [tile], al

	mov bh, 0
	mov bl, [piece]
	and bl, 0Fh
	cmp bl, 8 ; checks if it's a pawn
	jae dontMindPromotion
		mov al, [piece]
		and al, 10h
		shr al, 1
		add bl, al
		add bx, offset Wpromotions ; go to the correct pawn to view its promotion
		mov ax, [bx]
		shl ax, 1
		add si, ax
		mov si, [si] ; go to the correct sprite
	dontMindPromotion:
	
	mov ah, 0
	mov al, [tile]
	shr ax, 3 ; only look at the file
	shl ax, 4 ; multiply by 16 because the tile size is 16 px
	add ax, 96 ; add the offset of the board
	mov [Xp], ax ; this is the X coordinate of the up left corner of the piece
	mov cx, ax ; save the X coordinate
	
	mov ah, 0
	mov al, [tile]
	and ax, 7 ; look at the row
	shl ax, 4 ; multiply by 16 because the tile size is 16 px
	neg ax ; the rows are in bottom to top but the coordinates are from top to bottom
	add ax, 148 ; add the offset of the board
	mov [Yp], ax ; this is the Y coordinate of the up left corner of the piece
	
	
	mov ax, 0
	paintPieceLoop:
			mov dl, [si]
			cmp dl, 't'
			je paintPieceCon ; if pixel should be transparent then don't do anything
			
			cmp dl, 'b'
			jne insidePiece ; if it's a pixel in the border of the piece
				mov [color], 16h
				call putPixel
				jmp paintPieceCon
	
	paintPieceHelp:
	jmp paintPieceEnd
	
			insidePiece: ; if it's a pixel in the inside of the piece
				mov bl, [piece]
				and bl, 10h ; check if the piece is white or black
				jz whitePiece
					mov [color], 00h
					call putPixel
					jmp paintPieceCon
				whitePiece:
					mov [color], 0Fh
					call putPixel
					jmp paintPieceCon
			
			paintPieceCon:
			inc si
			inc [Xp]
			inc al
			cmp al, 16
			jb paintPieceLoop
		mov [Xp], cx
		mov al, 0
		inc [Yp]
		inc ah
		cmp ah, 16
		jb paintPieceLoop
					
	
	paintPieceEnd:
	pop si
	pop dx
	pop cx
	pop bx
	pop ax
	ret
endp paintPiece

proc showGame
	call background
	call paintButtons
	call displayBoard
	mov [piece], 0
	showGameLoop:
		call paintPiece
		inc [piece]
		cmp [piece], 20h
		jb showGameLoop
	ret
endp showGame

proc emptyTile ; activates the zero flag if [tile] doesn't contain piece of ah color
	push ax
	push bx
	push cx
	push dx
	
	mov al, ah
	shl al, 4
	mov ah, 0
	mov bx, offset Wpawns
	add bx, ax
	mov cx, 0
	emptyTileLoop: ; loop through every piece of the color
		mov cl, [bx]
		cmp cl, [tile]
		je isntEmpty ; if the piece is on [tile] then the tile isnt empty
	inc bx
	inc ch
	cmp ch, 16
	jb emptyTileLoop
	
	mov ax, 0
	jmp emptyTileEnd
	isntEmpty:
		mov ax, 1
	emptyTileEnd:
	and ax, 1
	pop dx
	pop cx
	pop bx
	pop ax
	ret
endp emptyTile

proc LegalMovePawn
	push ax
	push bx
	push cx
	push dx
	
	cmp ch, dh
	jne notForward
		; the move is forward
		xor ah, 1
		call emptyTile 
		jnz isntLegalPawnHelp ; pawns can't eat forward
		xor ah, 1
		shl ah, 1
		add dl, ah
		dec dl ; white pawns walk upward and black pawns walk downward 
		cmp cx, dx
		je isLegalPawnHelp ; the move is one step toward the other side
		; the move is more than 1 step foward
		add dl, ah
		dec dl
		cmp cx, dx
		jne isntLegalPawnHelp ; the move is more than 2 steps forward
		add [tile], ah
		dec [tile]
		shr ah, 1
		call emptyTile
		jnz isntLegalPawn ; allay piece is in the way
		xor ah, 1
		call emptyTile
		jnz isntLegalPawn ; enemy piece is in the way
		xor ah, 1
		jz whitePawn 
			cmp cl, 6
			jne isntLegalPawn ; pawns can only move twice from starting position
			jmp isLegalPawn
		whitePawn:
			cmp cl, 1
			jne isntLegalPawn ; pawns can only move twice from starting position
			jmp isLegalPawn
	
	
	isLegalPawnHelp:
		jmp isLegalPawn
	isntLegalPawnHelp:
		jmp isntLegalPawn
	
		notForward:
			shl ah, 1
			add dl, ah
			dec dl
			cmp cl, dl
			jne isntLegalPawn ; the move isnt to the next row
			sub dh, ch
			cmp dh, 0
			jl PawnToLeft
				cmp dh, 1
				jne isntLegalPawn ; the move isnt to the file right from the pawn
				jmp legalMovePawnCon				
			PawnToLeft:
				cmp dh, -1
				jne isntLegalPawn ; the move isnt to the file left from the pawn
				jmp legalMovePawnCon
			
			legalMovePawnCon:
			shr ah, 1
			xor ah, 1
			call emptyTile
			jnz isLegalPawn ; pawns can move one squere diagonaly if there's an enemy there
			; now check for en passant
			mov bx, offset WmovedTwice
			shl ah, 3
			add bl, ah
			add bl, ch
			add bl, dh
			mov al, [bx]
			cmp al, 1
			jne isntLegalPawn ; the correct pawn didnt move twice before
			shr ah, 3
			xor ah, 1
			neg ah
			add ah, 4
			cmp cl, ah
			jne isntLegalPawn ; not near the en passant pawn
			je isLegalPawn ; it is en passant
		
	isntLegalPawn:
		mov ax, 1
		jmp legalMovePawnEnd
	isLegalPawn:
		mov ax, 0
	legalMovePawnEnd:
	and ax, 1
	pop dx
	pop cx
	pop bx
	pop ax
	ret
endp LegalMovePawn

proc LegalMoveRook
	push ax
	push bx
	push cx
	push dx
	
	cmp cl, dl
	je rookHorizontal
		; the move isnt horizonatl
		cmp ch, dh
		jne isntLegalRook ; the move is not straight
		; the move is vertical
		cmp cl, dl
		jb rookUp
			; the move is down
			mov bl, 1
			mov bh, cl
			sub bh, dl
			jmp legalMoveRookCon
		rookUp:
			; the move is up
			mov bl, -1
			mov bh, dl
			sub bh, cl
			jmp legalMoveRookCon
	rookHorizontal:
		cmp ch, dh
		jb rookRight
			; the move is left
			mov bl, 8
			mov bh, ch
			sub bh, dh
			jmp legalMoveRookCon
		rookRight:
			; the move is right
			mov bl, -8
			mov bh, dh
			sub bh, ch
			jmp legalMoveRookCon
			
	legalMoveRookCon:
	; now adding bl to [tile] move tile towards the piece's position 
	; and bh is the number of times it needed to be added so that [tile] is the piece's tile
	rookLoop:
		add [tile], bl
		dec bh
		cmp bh, 0
		je isLegalRook ; the loop ended in success because tile reached thh piece
		mov ah, 0
		call emptyTile
		jnz isntLegalRook ; something white is in the way
		mov ah, 1
		call emptyTile
		jnz isntLegalRook ; something black is in the way
		jmp rookLoop
	
	isntLegalRook:
		mov ax, 1
		jmp legalMoveRookEnd
	isLegalRook:
		mov ax, 0
	legalMoveRookEnd:
	and ax, 1
	pop dx
	pop cx
	pop bx
	pop ax
	ret
endp LegalMoveRook

proc LegalMoveKnight
	push ax
	push bx
	push cx
	push dx
	
	; basically check the distance from the piece to the target tile using pythagoras's theorem
	sub cl, dl
	sub ch, dh
	mov al, cl
	imul cl
	mov bx, ax
	mov al, ch
	imul ch
	add bx, ax
	cmp bx, 5
	je isLegalKnight
	
	isntLegalKnight:
		mov ax, 1
		jmp legalMoveKnightEnd
	isLegalKnight:
		mov ax, 0
	legalMoveKnightEnd:
	and ax, 1
	pop dx
	pop cx
	pop bx
	pop ax
	ret
endp LegalMoveKnight

proc LegalMoveBishop
	push ax
	push bx
	push cx
	push dx
	
	sub cl, dl
	sub ch, dh
	cmp cl, ch
	je bishopUp
		; the move isnt the / diagonal
		neg cl
		cmp cl, ch
		jne isntLegalBishop ; the move is not a diagonal
		; the move is the \ diagonal
		neg cl
		cmp cl, 0
		jg bishopDownRight
			; the move is up left
			mov bl, 7
			mov bh, cl
			neg bh
			jmp legalMoveBishopCon
		bishopDownRight:
			; the move is down right
			mov bl, -7
			mov bh, cl
			jmp legalMoveBishopCon
	bishopUp:
		; the move is the / diagonal
		cmp cl, 0
		jl bishopUpRight
			; the move is down left
			mov bl, 9
			mov bh, cl
			jmp legalMoveBishopCon
		bishopUpRight:
			; the move is up right
			mov bl, -9
			mov bh, cl
			neg bh
			jmp legalMoveBishopCon
			
	legalMoveBishopCon:
	; now adding bl to [tile] move tile towards the piece's position 
	; and bh is the number of times it needed to be added so that [tile] is the piece's tile
	bishopLoop:
		add [tile], bl
		dec bh
		cmp bh, 0
		je isLegalBishop ; the loop ended in success because tile reached thh piece
		mov ah, 0
		call emptyTile
		jnz isntLegalBishop ; something white is in the way
		mov ah, 1
		call emptyTile
		jnz isntLegalBishop ; something black is in the way
		jmp bishopLoop
	
	isntLegalBishop:
		mov ax, 1
		jmp legalMoveBishopEnd
	isLegalBishop:
		mov ax, 0
	legalMoveBishopEnd:
	and ax, 1
	pop dx
	pop cx
	pop bx
	pop ax
	ret
endp LegalMoveBishop

proc LegalMoveQueen
	push ax
	push bx
	push cx
	push dx
	
	mov al, [tile]
	push ax
	call LegalMoveBishop
	pop ax
	jz isLegalQueen ; the queen moves diagonally
	mov [tile], al
	call legalMoveRook
	jz isLegalQueen ; the queen moves in straight lines
	
	isntLegalQueen:
		mov ax, 1
		jmp legalMoveQueenEnd
	isLegalQueen:
		mov ax, 0
	legalMoveQueenEnd:
	and ax, 1
	pop dx
	pop cx
	pop bx
	pop ax
	ret
endp LegalMoveQueen

proc LegalMoveKing
	push ax
	push bx
	push cx
	push dx
	push di
	
	mov di, offset Wpawns
	mov bl, [piece]
	mov bh, 0
	add di, bx
	mov bx, [di]
	push bx
	push di ; push the king's pointer and the king's position
	
	mov bl, [piece]
	mov bh, [targetTile]
	push bx
	
	sub cl, dl
	sub ch, dh
	cmp cl, 1
	jg isntLegalKingHelp ; the move is too down
	cmp cl, -1
	jl isntLegalKingHelp ; th move is too up
	cmp ch, 1
	jg bigCastle ; the move is too left
	cmp ch, -1
	jl smallCastle ; th move is too right
	jmp isLegalKingHelp
	
	bigCastle:
		;check if big castle is legal
		mov bh, 0
		mov bl, ah
		add bx, offset WbigCastle
		cmp [byte ptr bx], 0
		jne isntLegalKingHelp ; rook or king moved
		shl ah, 4
		mov [piece], 8
		add [piece], ah
		add [targetTile], 8
		call legalMove
		jnz isntLegalKingHelp ; the squers between the king in the rook aren't empty because the rook can't move to the king
		pop bx
		mov [piece], bl
		push bx ; retrive the original piece
		mov bx, 0
		mov bl, [piece]
		add bx, offset Wpawns
		shr ah, 4
		call inCheck
		jz isntLegalKingHelp ; checked king cant castle
		sub [byte ptr bx], 8
		call inCheck
		jz isntLegalKingHelp 
		sub [byte ptr bx], 8
		call inCheck
		jz isntLegalKing 
		sub [byte ptr bx], 8
		call inCheck
		jz isntLegalKing ; no tiles can be threatend in the castling
		sub [byte ptr bx], 8
		call inCheck
		jz isntLegalKing ; the rook cant be threatend in the castling
		jmp isLegalKing
	
	isLegalKingHelp:
		jmp isLegalKing
	isntLegalKingHelp:
		jmp isntLegalKing
	
	smallCastle:
		;check if big castle is legal
		mov bh, 0
		mov bl, ah
		add bx, offset WsmallCastle
		cmp [byte ptr bx], 0
		jne isntLegalKing ; rook or king moved
		shl ah, 4
		mov [piece], 9
		add [piece], ah
		sub [targetTile], 8
		call legalMove
		jnz isntLegalKing ; the squers between the king in the rook aren't empty
		mov [piece], 0Fh
		add [piece], ah
		pop bx
		mov [piece], bl
		push bx ; retrive the original piece
		shr ah, 4
		call inCheck
		jz isntLegalKing ; checked king cant castle
		add [byte ptr bx], 8
		call inCheck
		jz isntLegalKing 
		add [byte ptr bx], 8
		call inCheck
		jz isntLegalKing ; no tiles can be threatend in the castling
		add [byte ptr bx], 8
		call inCheck
		jz isntLegalKing ; the rook cant be threatend in the castling
		jmp isLegalKing
	
	
	
		
	
	isntLegalKing:
		mov ax, 1
		jmp legalMoveKingEnd
	isLegalKing:
		mov ax, 0
	legalMoveKingEnd:
	pop bx
	mov [piece], bl
	mov [targetTile], bh
	
	and ax, 1
	pop di
	pop bx
	mov [di], bx
	
	pop di
	pop dx
	pop cx
	pop bx
	pop ax
	ret
endp LegalMoveKing

proc legalMove ; activates the zero flag if the move of [piece] to [tile] is legal
	push ax
	push bx
	push cx
	push dx
	mov al, [targetTile]
	mov [tile], al
	
	mov ah, 0
	mov al, [piece]
	mov bx, offset Wpawns
	add bx, ax 
	mov ah, al
	and al, 0Fh
	shr ah, 4
	; al is the piece and ah is the color of the piece
	
	mov dl, [bx]
	test dl, 40h
	jnz legalMoveHelp ; if the piece is eaten then the move isn't legal
	
	mov cl, [bx]
	mov ch, [bx]
	shr ch, 3
	and cl, 7
	; ch is file of piece and cl is row of [piece]
	mov dl, [tile]
	mov dh, [tile]
	shr dh, 3
	and dl, 7
	; dh is file of piece and dl is row of [tile]
	
	call emptyTile
	legalMoveHelp:
	jnz isntLegalMove ; if [tile] has a piece of the same color then the move is ilegal
	
	cmp al, 08h
	jae notPawn
		; the piece is a pawn or a promoted pawn
		mov bx, 0
		mov bl, ah
		shl bl, 3
		add bl, al
		add bx, offset Wpromotions
		mov bl, [bx]
		cmp bl, 1
		je isRook
		cmp bl, 2
		je isKnight
		cmp bl, 3
		je isBishop
		cmp bl, 4
		je isQueen
		; the piece is an unpromoted pawn
		call LegalMovePawn
		jz isLegalMove
		jnz isntLegalMove
	
	notPawn:
	cmp al, 0Ah
	jae notRook
	isRook:
		call LegalMoveRook
		jz isLegalMove
		jnz isntLegalMove
	notRook:
	cmp al, 0Ch
	jae notKnight
	isKnight:
		call LegalMoveKnight
		jz isLegalMove
		jnz isntLegalMove
	notKnight:
	cmp al, 0Eh
	jae notBishop
	isBishop:
		call LegalMoveBishop
		jz isLegalMove
		jnz isntLegalMove
	notBishop:
	cmp al, 0Fh
	je isKing
	isQueen: 
		call LegalMoveQueen
		jz isLegalMove
		jnz isntLegalMove
	isKing:
		call LegalMoveKing
		jz isLegalMove
		jnz isntLegalMove
	
	
	
	isntLegalMove:
		mov ax, 1
		jmp legalMoveEnd
	isLegalMove:
		mov ax, 0
	legalMoveEnd:
	and ax, 1
	pop dx
	pop cx
	pop bx
	pop ax
	ret
endp legalMove 
	
proc inCheck ; checks if the king of color ah is in check
	push ax
	push bx
	push cx
	push dx
	
	mov bx, offset Wking
	shl ah, 4
	add bl, ah ; find the king of the correct color
	mov al, [bx]
	mov [targetTile], al ; the target tile is the king's tile
	mov [piece], 10h
	xor [piece], ah ; the pieces checking are of the opposite color
	mov cx, 16
	inCheckLoop:
		call legalMove
		jz check
		inc [piece]
		loop inCheckLoop
	; for each piece of the opposite color, check if it can move to the king's tile
	
	safe:
		mov ax, 1
		jmp inCheckEnd
	check:
		mov ax, 0
	inCheckEnd:
	and ax, 1
	pop dx
	pop cx
	pop bx
	pop ax
	ret
endp inCheck

proc resetMovedTwice
	push ax
	push bx
	push cx
	push dx
	
	mov bx, offset WmovedTwice
	mov cx, 16
	resetMovedTwiceLoop:
		mov [byte ptr bx], 0
		inc bx
		loop resetMovedTwiceLoop
	
	pop dx
	pop cx
	pop bx
	pop ax
	ret
endp resetMovedTwice

proc doMove
	push ax
	push bx
	push cx
	push dx
	
	call resetMovedTwice ; reset the [XmovedTwice] to to avoid en passants more than one turn after moving twice
	
	mov al, [piece]
	mov ah, [piece]
	and al, 0Fh ; al is the piece itself
	shr ah, 4 ; ah is the color of the piece
	cmp al, 8
	jae notPawnMoveHelp
	mov bl, ah
	shl bl, 3
	mov bh, 0
	add bl, al
	add bx, offset Wpromotions
	cmp [byte ptr bx], 0
	jne notPawnMoveHelp ; the piece is a promoted pawn
	
		; toggle [W/BmovedTwice]
		xor ah, 1
		mov bl, [piece]
		mov bh, 0
		add bx, offset Wpawns
		mov cl, [bx]
		shr cl, 3
		mov ch, [targetTile]
		shr ch, 3
		cmp cl, ch
		je notEnPassant ; the move is straight so it's not en passant
		mov dl, [targetTile]
		mov [tile], dl
		call emptyTile
		jz doEnPassant ; the move is to an empty squere so it's an en passant
		
		notEnPassant:
		xor ah, 1
		mov bl, [piece]
		mov bh, 0
		add bx, offset Wpawns
		mov cl, [bx]
		and cl, 7
		mov ch, [targetTile]
		and ch, 7
		sub ch, cl
		cmp ch, 2
		je DoubleMovePawn
		cmp ch, -2
		jne doMoveEndHelp
		
		DoubleMovePawn:
		mov bx, offset WmovedTwice
		shl ah, 3
		add bl, ah
		add bl, al
		mov [byte ptr bx], 1
		jmp doMoveEnd
		
	notPawnMoveHelp:
		jmp notPawnMove
	
		doEnPassant:
			mov [Melody], offset enPassantMelody
			mov bx, 0
			shl ah, 4
			add bl, ah
			shr dl, 3
			add bl, dl ; point bx to the pawn of the opposite color of the same file as the target tile
			add bx, offset Wpawns
			or [byte ptr bx], 40h ; eat that pawn
			jmp doMoveEnd
			
	notPawnMove:
	cmp al, 0Ah
	jae notRookMove
		cmp al, 8
		je moveLeftRook
			; cant do small castling
			mov bx, offset WsmallCastle
			add bl, ah
			mov [byte ptr bx], 1
			jmp doMoveEnd
		moveLeftRook:
			; cant do big castling
			mov bx, offset WbigCastle
			add bl, ah
			mov [byte ptr bx], 1
			jmp doMoveEnd
	
	doMoveEndHelp:
		jmp doMoveEnd
	
	notRookMove:
	cmp al, 0Fh
	jne doMoveEnd
		; cant do castling at all after this move
		mov bx, 0
		mov bl, ah
		add bx, offset WsmallCastle
		mov [byte ptr bx], 1
		mov bx, 0
		mov bl, ah
		add bx, offset WbigCastle
		mov [byte ptr bx], 1
		mov bx, 0
		mov bl, [piece]
		add bx, offset Wpawns
		mov cl, [bx]
		shr cl, 3
		mov ch, [targetTile]
		shr ch, 3
		sub cl, ch
		cmp cl, 2
		je doBigCastling
		cmp cl, -2
		je doSmallCastling
		jmp doMoveEnd
		
		doBigCastling:
			mov bx, offset Wrooks
			shl ah, 4
			add bl, ah
			add [byte ptr bx], 18h
			jmp doMoveEnd
		doSmallCastling:
			mov bx, offset Wrooks+1
			shl ah, 4
			add bl, ah
			sub [byte ptr bx], 10h		
		
	doMoveEnd:
	mov bx, offset Wpawns
	mov cx, 32
	doMoveLoop:
		mov al, [bx]
		cmp al, [targetTile]
		je eat
		inc bx
		loop doMoveLoop
	jmp doMoveCon
	; for each piece, if its in the target tile, eat it
	
	eat:
		or [byte ptr bx], 40h
		mov [Melody], offset eatMelody
	
	doMoveCon:
	mov bx, 0
	mov bl, [piece]
	add bx, offset Wpawns
	mov al, [targetTile]
	mov [bx], al ; move the moved piece to the targeted tile
	
	pop dx
	pop cx
	pop bx
	pop ax
	ret
endp doMove

proc legalTurn
	push ax
	push bx
	push cx
	push dx
	mov al, [piece]
	mov ah, [targetTile]
	push ax
	
	mov cx, 34
	mov bx, offset Wpawns
	legalTurnPushLoop:
		push [word ptr bx]
		add bx, 2
		loop legalTurnPushLoop
	; push the state of the board to the stack
	
	call legalMove
	jnz isntLegalTurn
	call doMove
	mov ah, [piece]
	shr ah, 4
	call inCheck ; check if the king of the 
	jnz isLegalTurn
	
	
	isntLegalTurn:
		mov ax, 1
		jmp legalTurnEnd
	isLegalTurn:
		mov ax, 0
	legalTurnEnd:
	mov cx, 34
	mov bx, offset Wpawns+68
	legalTurnPopLoop:
		sub bx, 2
		pop [word ptr bx]
		loop legalTurnPopLoop
	; pop the state of the board from the stack
	
	and ax, 1
	pop ax
	mov [piece], al
	mov [targetTile], ah
	pop dx
	pop cx
	pop bx
	pop ax
	ret
endp legalTurn

proc config
	push ax
	push bx
	push cx
	push dx
	

	mov ax, 13h
	int 10h ; go to graphic mode
	
	mov ax, 0h
	int 33h ; enables mouse
		
	pop dx
	pop cx
	pop bx
	pop ax
	ret
endp config

proc waitTick
	push ax
	
	mov ax, 40h
	mov es, ax
	
	mov ax, [clock]
	waitTickLoop:
		cmp ax, [clock]
		je waitTickLoop
	
	pop ax
	ret
endp waitTick
	
proc selectTile
	push ax
	push bx
	push cx
	push dx
	
	selectTileLoop: ; loop continues until the mouse is pressed inside the board
		call useMouse
		
		; check if a button if pressed
		cmp [isDraw], 1
		je selectTileEnd 
		cmp [isResign], 1
		je selectTileEnd 
		
		mov cx, [Xmouse]
		mov dx, [Ymouse]
		cmp cx, 96
		jb selectTileLoop ; press is too left
		cmp cx, 224
		jae selectTileLoop ; press is too right
		cmp dx, 36
		jb selectTileLoop ; press is too up
		cmp dx, 164
		jae selectTileLoop ; press is too down
	
	mov bl, 16
	sub cx, 96
	sub dx, 36
	shr cx, 4
	shl cx, 3
	shr dx, 4
	neg dx
	add dx, 7
	mov [tile], cl
	add [tile], dl
	
	call markTile
	
	selectTileEnd:
	pop dx
	pop cx
	pop bx
	pop ax
	ret
endp selectTile

proc markTile
	push ax
	push bx
	push cx
	push dx
	
	mov ah, 0
	mov al, [tile]
	shr ax, 3 ; only look at the file
	shl ax, 4 ; multiply by 16 because the tile size is 16 px
	add ax, 96 ; add the offset of the board
	mov [Xp], ax ; this is the X coordinate of the up left corner of the tile
	mov cx, ax ; save the X coordinate
	
	mov ah, 0
	mov al, [tile]
	and ax, 7 ; look at the row
	shl ax, 4 ; multiply by 16 because the tile size is 16 px
	neg ax ; the rows are in bottom to top but the coordinates are from top to bottom
	add ax, 148 ; add the offset of the board
	mov [Yp], ax ; this is the Y coordinate of the up left corner of the tile
	
	mov dx, 0
	markTileLoop:
			call readPixel
			cmp [color], 0Fh
			jne notWhitePixel
				mov [color], 58h
				jmp markTileCon
			notWhitePixel:
			cmp [color], 16h
			jne blackPixel
				mov [color], 70h
				jmp markTileCon
			blackPixel:
				mov [color], 28h
				jmp markTileCon
			
			markTileCon:
			call putPixel
		inc [Xp]
		inc dl
		cmp dl, 16
		jne markTileLoop
	mov [Xp], cx
	mov dl, 0
	inc [Yp]
	inc dh
	cmp dh, 16
	jne markTileLoop
		
	pop dx
	pop cx
	pop bx
	pop ax
	ret
endp markTile

proc selectPiece ; select a piece of ah color
	push ax
	push bx
	push cx
	push dx
	
	mov al, ah
	shl al, 4
	selectPieceLoop: ; loop until a piece of ah is selected
		call showGame
		call selectTile
		
		; check if a button if pressed
		cmp [isDraw], 1
		je selectPieceEnd 
		cmp [isResign], 1
		je selectPieceEnd 
		
		mov ah, 0
		mov bx, ax
		add bx, offset Wpawns
		mov cx, 16
		mov [piece], al
		selectPieceLoop2: ; loop through all of the pieces of ah and check if they are in the tile selected
			mov ah, [bx]
			cmp [tile], ah
			je selectPieceEnd
			inc bx
			inc [piece]
			loop selectPieceLoop2
		jmp selectPieceLoop
	
	selectPieceEnd:
	pop dx
	pop cx
	pop bx
	pop ax
	ret
endp selectPiece

proc selectMove
	push ax
	push bx
	push cx
	push dx
	
	selectMoveLoop: ; loop until a legal move of ah is selected
		call showGame
		call selectPiece
		call selectTile
		
		; check if a button if pressed
		cmp [isDraw], 1
		je selectMoveEnd 
		cmp [isResign], 1
		je selectMoveEnd 
		
		mov al, [tile]
		mov [targetTile], al
		call legalTurn
		jnz selectMoveLoop
	
	selectMoveEnd:
	pop dx
	pop cx
	pop bx
	pop ax
	ret
endp selectMove

proc inMate ; check if ah player is in mate (cant do a legal turn)
	push ax
	push bx
	push cx
	push dx
	mov bl, [targetTile]
	mov bh, [piece]
	push bx
	
	shl ah, 4
	mov bl, ah
	mov al, 0
	mov cx, 16
	inMateLoop: ; loop through every piece-tile pair and check if it's a legal turn
			mov [targetTile], al
			mov [piece], bl
			call legalTurn
			jz able
			inc bl
			loop inMateLoop
		mov cx, 16
		mov bl, ah
		inc al
		cmp al, 64
		jne inMateLoop
	jmp mate
	
	able:
		mov ax, 1
		jmp inMateEnd
	mate:
		mov ax, 0
	inMateEnd:
	and ax, 1
	pop ax
	mov [targetTile], al
	mov [piece], ah
	pop dx
	pop cx
	pop bx
	pop ax
	ret
endp inMate

proc checkmate
	push ax
	push bx
	push cx
	push dx
	
	call inCheck
	jnz notCheckmated
	call inMate
	jz checkmated
	
	notCheckmated:
		mov ax, 1
		jmp checkmateEnd
	checkmated:
		mov ax, 0
	checkmateEnd:
	and ax, 1
	pop dx
	pop cx
	pop bx
	pop ax
	ret
endp checkmate

proc stalemate
	push ax
	push bx
	push cx
	push dx
	
	call inCheck
	jz notStalemated
	call inMate
	jz stalemated
	
	notStalemated:
		mov ax, 1
		jmp checkmateEnd
	stalemated:
		mov ax, 0
	stalematedEnd:
	and ax, 1
	pop dx
	pop cx
	pop bx
	pop ax
	ret
endp stalemate

proc printStr
	push ax
	push bx
	push cx
	push dx
	push es
	
	mov ax, ds
	mov es, ax
	
	mov bp, [String]
	mov bl, [ds:bp]
	mov bh, 0
	inc bp
	mov cl, [ds:bp]
	mov ch, 0
	inc bp
	mov dl, [Xstr]
	mov dh, [Ystr]
	mov ax, 1300h
	int 10h
	
	pop es
	pop dx
	pop cx
	pop bx
	pop ax
	ret
endp printStr

proc turn
	push ax
	push bx
	push cx
	push dx
	
	mov [Melody], 0
	
	call selectMove
	
	; check if a button if pressed
	cmp [isDraw], 1
	je turnEnd 
	cmp [isResign], 1
	je turnEnd 
	
	call doMove
	; now check if you should promote
	mov al, [piece]
	and al, 0Fh
	cmp al, 8
	jae turnEnd ; not a pawn
	mov bx, 0
	mov bl, [piece]
	add bx, offset Wpromotions
	cmp [byte ptr bx], 0
	jne turnEnd ; the piece is a promoted pawn
	mov al, [targetTile]
	and al, 7
	sub al, ah
	inc al
	and al, 7
	jnz turnEnd ; not at the other end of the board
	mov [Melody], offset promotionMelody
	; print the promotion menu
	mov [Xstr], 8
	mov [Ystr], 1
	mov [String], offset promoMenu
	call printStr
	inc [Ystr]
	mov [String], offset promoMenu2
	call printStr
	;promotion
	mov bh, 0
	mov bl, [piece]
	and bx, 7
	mov al, ah
	shl al, 3
	mov ah, 0
	add bx, ax
	add bx, offset Wpromotions
	
	promotionLoop: ; loop until a valid key is pressed
		mov ah, 00h
		int 16h
		sub al, 30h
		cmp al, 1
		jb promotionLoop ; ASCII code too low
		cmp al, 4
		ja promotionLoop ; ASCII code too high
	
	mov [bx], al ; promote
	
	turnEnd:
	call showGame
	cmp [Melody], 0
	je nothingHappend
		call playMelody
	nothingHappend:
	pop dx
	pop cx
	pop bx
	pop ax
	ret
endp turn

proc paintButtons
	push ax
	push bx
	push cx
	push dx
	
	; paint the draw button
	mov [Xp], 10
	mov [Yp], 10
	mov bx, offset DrawButton
	
	paintDrawButtonLoop:
			mov al, [bx]
			mov [color], al
			call putPixel
		inc [Xp]
		inc bx
		cmp [Xp], 42
		jb paintDrawButtonLoop
	mov [Xp], 10
	inc [Yp]
	cmp [Yp], 26
	jb paintDrawButtonLoop
	
	; paint the resign button
	
	mov [Xp], 10
	mov [Yp], 174
	mov bx, offset ResignButton
	
	paintResignButtonLoop:
			mov al, [bx]
			mov [color], al
			call putPixel
		inc [Xp]
		inc bx
		cmp [Xp], 42
		jb paintResignButtonLoop
	mov [Xp], 10
	inc [Yp]
	cmp [Yp], 190
	jb paintResignButtonLoop
	
	pop dx
	pop cx
	pop bx
	pop ax
	ret
endp paintButtons

proc gameEnd
	push ax
	push bx
	push cx
	push dx

	mov [String], offset exitStr
	mov [Xstr], 9
	mov [Ystr], 12
	call printStr
	
	
	mov ah, 00h
	int 16h ; wait until a key is pressed
	
	mov ah, 0
	mov al, 2
	int 10h ; back to text mode
	
	pop dx
	pop cx
	pop bx
	pop ax
	ret
endp gameEnd

proc playMelody
	push ax
	push bx
	push cx
	push dx
	push es
	push si
	
	mov ah, 1
	int 16h
	jz bufferClear
	mov ah, 0 ; clears the keyboard buffer
	int 16h
	bufferClear:
	
	mov si, [Melody]
	
	call waitTick
	
	playMelodyLoop:
	
		mov bl, [si]
		cmp bl, 0
		je melodyEndHelp ;reached the end of the melody
		cmp bl, "!"
		je isRest
		
		sub bl, 61h
		mov bh, 0
		inc si
		mov al, [si]
		cmp al, 30h
		jae calculateOctave ; check if the note is not natrual flat or sharp
			inc si
			sub al, 22h
			mov cl, 7
			mul cl
			add bx, ax
			mov al, [si]
		calculateOctave:
		shl bx, 1
		add bx, offset natrualNotesTable
		mov cl, al
		sub cl, 30h
		mov ax, [bx]
		shr ax, cl ; devides ax by 2 for every higher octave
		
		inc si
		mov cl, [si]
		sub cl, 30h
		mov ch, 0 
		shl cx, 2
		sub cx, 1 ; cx is the number of the ticks
		
		push ax
		in al, 61h
		or al, 11b
		out 61h, al ; turns on the speaker
	
		mov al, 0B6h
		out 43h, al ; send control word to change frequency
		pop ax
		
		out 42h, al ; Sending lower byte
		mov al, ah
		out 42h, al ; Sending upper byte
		
		noteDuration:
			mov ah, 1
			int 16h
			jz KeyNotPressed
			mov ah, 0 ; there is a key in the buffer, read it and clear the buffer
			int 16h
			cmp ax, 011bh
			je melodyEnd
			KeyNotPressed:
			call waitTick
			loop noteDuration ; wait until the note is finished
		
		add si, 2
		
		in al, 61h
		and al, 11111100b
		out 61h, al ; turn of speaker
		
		call waitTick ; need seperation between notes
		
		jmp playMelodyLoop
		
melodyEndHelp:
	jmp melodyEnd

		isRest:
			inc si
			mov cl, [si]
			sub cl, 30h
			mov ch, 0
			shl cx, 2
			
			restDuration:
				call waitTick
				loop restDuration ; wait until the rest is finished
			
			add si, 2
			jmp playMelodyLoop
			
		
	melodyEnd:
	
	in al, 61h
	and al, 11111100b
	out 61h, al ; turn of speaker
	
	pop si
	pop es
	pop dx
	pop cx
	pop bx
	pop ax
	ret
endp playMelody

proc useMouse
	push ax
	push bx
	push cx
	push dx
	
	mov ax, 1
	int 33h ; show mouse
	
	useMouseLoop:
		mov ax, 3
		int 33h
		shr cx, 1
		cmp bl, 1
		jne useMouseLoop ; check the mouse's status until it's pressed
	
	;check if any button is pressed
	cmp cx, 10
	jb useMouseEnd ; left to the button
	cmp cx, 42
	jae useMouseEnd ; right to the button
	
	;check if the draw button is pressed
	cmp dx, 10
	jb useMouseCon ; above the button
	cmp dx, 26
	jae useMouseCon ; just right
	mov [isDraw], 1
	
	useMouseCon:
	;check if the resign button is pressed
	cmp dx, 174
	jb useMouseEnd ; above the button
	cmp dx, 190
	jae useMouseCon ; below the button
	mov [isResign], 1
	
	
	useMouseEnd:
	mov [Xmouse], cx
	mov [Ymouse], dx
	
	mousePressedLoop:
		mov ax, 3
		int 33h
		shr cx, 1
		cmp bl, 0
		jne mousePressedLoop
	
	mov ax, 2
	int 33h ; hide mouse
	
	pop dx
	pop cx
	pop bx
	pop ax
	ret
endp useMouse


start:
	mov ax, @data
	mov ds, ax
	
	call config
	call showGame
	mov ah, 0
	mov [Melody], offset startMelody
	call playMelody
	
	mainLoop:
		call checkmate
		jz someoneWon
		call stalemate
		jz draw
		call turn
		
		; check if a button if pressed
		cmp [isDraw], 1
		je draw
		cmp [isResign], 1
		je someoneWon 
		
		xor ah, 1
		call inCheck
		jnz notInCheck
			mov [Melody], offset CheckMelody
			call playMelody
		notInCheck:
		jmp mainLoop
		
	someoneWon:
		mov [Melody], offset winningMelody
		cmp ah, 0
		je blackWins
		whiteWins:
			mov [Xstr], 14
			mov [Ystr], 2
			mov [String], offset WwinStr
			call printStr
			jmp exit
		blackWins:
			mov [Xstr], 14
			mov [Ystr], 2
			mov [String], offset BwinStr
			call printStr
			jmp exit
			
	draw:
		mov [Xstr], 18
		mov [Ystr], 2
		mov [String], offset drawStr
		call printStr
		mov [Melody], offset drawMelody
	
	exit:
	call playMelody
	call gameEnd
	mov ax, 4c00h
	int 21h;
END start